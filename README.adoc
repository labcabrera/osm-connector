= Oracle Struct Metadata Connector

image:https://travis-ci.org/labcabrera/osm-connector.svg?branch=master["Build Status", link="https://travis-ci.org/labcabrera/osm-connector"]
image:https://api.codacy.com/project/badge/Grade/d2e9f91dea274cdcb58c902197b7ac3f["Codacy code quality", link="https://www.codacy.com/app/lab.cabrera/osm-connector?utm_source=github.com&utm_medium=referral&utm_content=labcabrera/osm-connector&utm_campaign=Badge_Grade"]

:structMapper: https://github.com/labcabrera/osm-connector/blob/master/src/main/java/org/lab/osm/connector/mapper/StructMapper.java[StructMapper]
:arrayMapper: https://github.com/labcabrera/osm-connector/blob/master/src/main/java/org/lab/osm/connector/mapper/ArrayMapper.java[ArrayMapper]
:oracleStruct: https://github.com/labcabrera/osm-connector/blob/master/src/main/java/org/lab/osm/connector/annotation/OracleStruct.java[@OracleStruct]
:oracleField: https://github.com/labcabrera/osm-connector/blob/master/src/main/java/org/lab/osm/connector/annotation/OracleField.java[@OracleField]
:oracleCollection: https://github.com/labcabrera/osm-connector/blob/master/src/main/java/org/lab/osm/connector/annotation/OracleCollection.java[@OracleCollection]
:metadataStructMapper: https://github.com/labcabrera/osm-connector/blob/master/src/main/java/org/lab/osm/connector/mapper/impl/MetadataStructMapper.java[MetadataStructMapper]
:storedProcedureExecutor: https://github.com/labcabrera/osm-connector/blob/master/src/main/java/org/lab/osm/connector/handler/StoredProcedureExecutor.java[StoredProcedureExecutor]
:enableOsmConnector: https://github.com/labcabrera/osm-connector/blob/master/src/main/java/org/lab/osm/connector/EnableOsmConnector.java[@EnableOsmConnector]

:linkSpringJdbc: https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html[Spring JDBC]
:linkOsmCodeGenerator: https://github.com/labcabrera/osm-code-generator[OSM Code Generator]

== Introducción

Librería que simplifica el acceso a procedimientos almacenados de Oracle utilizando
{linkSpringJdbc} a partir de un sistema basado en anotaciones.

La librería ofrece las siguietes funcionalidades:

* Mapeo de tipo de datos de Oracle basado en anotaciones.
* Invocación de lógicas de negocio de Oracle a través de interfaces (similar al sistema de
  repositorios utilizado por Spring Data).
* Generación automática de código utilizando {linkOsmCodeGenerator}.
* Serialización de tipos para evitar accesos innecesarios en las conversiones de los objetos del
  driver de Oracle.

== Mapeo de entidades

La librería define la interface {structMapper} que es la que se encargará de realizar las
transformaciones de nuestras entidades de Java a objetos de Oracle. La definición es muy sencilla:

[source,java]
----
public interface StructMapper<T> {

	STRUCT toStruct(T source, Connection conn) throws SQLException;

	T fromStruct(STRUCT struct) throws SQLException;
}
----

Esta interface está implementada por la clase {structMapper} que utiliza un metamodelo basado en
anotaciones similar a JPA para hacer las conversiones de tipos.

Para el tratamiento de colecciones existe la interface equivalente {arrayMapper} encargada de
las conversiones del objeto _ARRAY_ del driver de Oracle a listas de entidades.

=== Definición del modelo

En primer lugar tendremos que definir las entidades de nuestro modelo a través de anotaciones que
nos permitirán hacer las conversiones de tipos.

Las anotaciones que utilizaremos serán:

|===
|{oracleStruct}     | Utilizada para establecer el nombre de la entidad de Oracle en nuestra clase
                      java.
|{oracleField}      | Utilizada para establecer el nombre de un campo de una entidad de Oracle de
                      un modo similar al `@Column` de JPA.
|{oracleCollection} | Utilizada para mapear una lista de objetos en nuestra entidad de java
                      representando una colección de Oracle. 
|===

De este modo por ejemplo tendremos:

[source,java]
----
@OracleStruct("ORACLE_MODEL_CUSTOMER")
public class Customer {

  @OracleField("ORACLE_MODEL_ID")
  private Long id;
  
  @OracleField("ORACLE_MODEL_NAME")
  private String name;
    
  @OracleCollection("ORACLE_MODEL_PRODUCT_LIST")
  private List<Product> products;

  private Address address;

}
----

== Invocación de procedimientos

Tenemos dos opciones:

* Utilizar el sistema basado en interfaces similar al funcionamiento de `JpaRepository` de Spring
  Framework.
* Extender el objeto `org.springframework.jdbc.object.StoredProcedure` utilizando la
  funcionalidad de {structMapper} para la conversión de tipos.

=== Utilizando interfaces

En primer lugar deberemos declarar nuestra interface extendiendo de {storedProcedureExecutor}.

Nuestra interface deberá tener la anotación {oracleStoredProcedure} que será la encargada de
establecer tanto el nombre del procedimiento o función como los argumentos de entrada salida.

Por ejemplo para invocar a una función de Oracle que recibe como parámetro de entrada un objeto de
tipo _ORACLE_CUSTOMER_MODEL_ y devuelve una lista de objetos del mismo tipo simplemente tendremos
que declarar la interface:

[source,java]
----
@OracleStoredProcedure(
  name = "SP_CUSTOMER_SEARCH",
  oraclePackage = "OSM_TEST_PACKAGE",
  owner = "OSM_TEST"
  isFunction = true,
  parameters = {
    @OracleParameter(
      name = "ORACLE_MODEL_CUSTOMER_COLLECTION",
      type = Types.ARRAY,
      mode = ParameterType.OUT,
      returnStructClass = Customer.class),
    @OracleParameter(
      name = "ORACLE_CUSTOMER_MODEL", 
      type = Types.STRUCT,
      mode = ParameterType.IN)
    })
public interface CustomerReaderExecutor extends StoredProcedureExecutor {
}
----

Sin la necesidad de definir ningún metodo dentro de nuestra interface, que extenderá el método que
utilizaremos para invocar a nuestro procedimiento almacenado de acuerdo a:

[source,java]
----
public interface StoredProcedureExecutor {

	Map<String, Object> execute(Object... args);

}
----

Los argumentos de entrada serán un array de objetos que deberá coincidir con los argumentos de
entrada definidos por el procedimiento, y como resultado revolverá un mapa con los diferentes
parámetros de salida.


== Configuración del conector

La forma más sencilla de configurar el conector es simplemente añadir la anotación
{enableOsmConnector} en nuestras clases de configuración de Spring:

[source,java]
----
@EnableOsmConnector(
  modelPackages = "org.lab.samples.osm.participant.model",
  executorPackages = "org.lab.samples.osm.participant.executor")
public class MyApplicationConfiguration { ... }
----

Como alternativa a utilizar esta anotación simplementente tendremos que declarar los siguientes
beans en nuestras clases de configuración:

* `MetadataCollector`
* `StructDefinitionService`
* `StructMapperService`
* `OracleStoredProcedureAnnotationProcessor`
* `StoredProcedureHandlerParameterProcessor`

== Generación automática de código

En lugar de generar tanto el modelo como las clases de forma manual podemos utilizar el proyecto
{linkOsmCodeGenerator}.

== Requisitos

* JDK 8+
* Spring Framework 4.x+
* Oracle Driver ojdbc6
