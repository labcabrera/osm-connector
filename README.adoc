:linkOracleStruct: https://github.com/labcabrera/osm-connector/blob/master/src/main/java/org/lab/osm/connector/annotation/OracleStruct.java
:linkOracleField: https://github.com/labcabrera/osm-connector/blob/master/src/main/java/org/lab/osm/connector/annotation/OracleField.java
:linkOracleCollection: https://github.com/labcabrera/osm-connector/blob/master/src/main/java/org/lab/osm/connector/annotation/OracleCollection.java

= Oracle Struct Metadata Connector

image:https://travis-ci.org/labcabrera/osm-connector.svg?branch=master["Build Status", link="https://travis-ci.org/labcabrera/osm-connector"]
image:https://api.codacy.com/project/badge/Grade/d2e9f91dea274cdcb58c902197b7ac3f["Codacy code quality", link="https://www.codacy.com/app/lab.cabrera/osm-connector?utm_source=github.com&utm_medium=referral&utm_content=labcabrera/osm-connector&utm_campaign=Badge_Grade"]

== Introducción

Librería que simplifica el acceso a procedimientos almacenados de Oracle utilizando
https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html[spring-jdbc]
a partir de un sistema basado en anotaciones.

La librería ofrece las siguietes funcionalidades:

* Mapeo de tipo de datos de Oracle basado en anotaciones.
* Invocación de lógicas de negocio de Oracle a través de interfaces (similar al sistema de
  repositorios utilizado por Spring Data).
* Generación automática de código utilizando https://github.com/labcabrera/osm-code-generator[osm-code-generator].
* Serialización de tipos para evitar accesos innecesarios en las conversiones de los objetos del driver de Oracle.

== Mapeo de entidades

La librería define la interface `StructMapper` que es la que se encargará de realizar las
transformaciones de nuestras entidades de Java a objetos de Oracle. La definición es muy sencilla:

[source,java]
----
public interface StructMapper<T> {

	STRUCT toStruct(T source, Connection conn) throws SQLException;

	T fromStruct(STRUCT struct) throws SQLException;
}
----

Esta interface está implementada por la clase `MetadataStructMapper` que utiliza un metamodelo
basado en anotaciones para hacer las conversiones de tipos.

=== Definición del modelo

En primer lugar tendremos que definir las entidades de nuestro modelo a través de anotaciones que
nos permitirán hacer las conversiones de tipos.

Las anotaciones que utilizaremos serán:

|===
|{linkOracleStruct}[@OracleStruct]         | Utilizada para establecer el nombre de la entidad de Oracle en nuestra clase
                                             java.
|{linkOracleField}[@OracleField]           | Utilizada para establecer el nombre de un campo de una entidad de Oracle de un
                                             modo similar al `@Column` de JPA.
|{linkOracleCollection}[@OracleCollection] | Utilizada para mapear una lista de objetos en nuestra entidad de java
                                             representando una colección de Oracle. 
|===

De este modo por ejemplo tendremos:

[source,java]
----
@OracleStruct("ORACLE_MODEL_CUSTOMER")
public class Customer {

  @OracleField("ORACLE_MODEL_ID")
  private Long id;
  
  @OracleField("ORACLE_MODEL_NAME")
  private String name;
    
  @OracleCollection("ORACLE_MODEL_PRODUCT_LIST")
  private List<Product> products;

  private Address address;

}
----

== Invocación de procedimientos

Tenemos dos opciones:

* Utilizar el sistema basado en interfaces similar al funcionamiento de `JpaRepository` de Spring
  Framework.
* Extender el objeto `org.springframework.jdbc.object.StoredProcedure` utilizando la funcionalidad
  de `StructMapper` para la conversión de tipos.

=== Utilizando interfaces

TODO

Por ejemplo para invocar a una función de Oracle que recibe como parámetro de entrada un objeto de
tipo _ORACLE_CUSTOMER_MODEL_ y devuelve una lista de objetos del mismo tipo simplemente tendremos
que declarar la interface:

[source,java]
----
@OracleStoredProcedure(
  name = "SP_CUSTOMER_SEARCH",
  oraclePackage = "OSM_TEST_PACKAGE",
  owner = "OSM_TEST"
  isFunction = true,
  parameters = {
    @OracleParameter(
      name = "ORACLE_MODEL_CUSTOMER_COLLECTION",
      type = Types.ARRAY,
      mode = ParameterType.OUT,
      returnStructClass = Customer.class),
    @OracleParameter(
      name = "ORACLE_CUSTOMER_MODEL", 
      type = Types.STRUCT,
      mode = ParameterType.IN)
    })
public interface CustomerReaderExecutor extends StoredProcedureExecutor {
}
----

////
=== Utilizando directamente procedimientos almacenados

TODO
////

== Generación automática de código

En lugar de generar tanto el modelo como las clases de forma manual podemos utilizar el proyecto
https://github.com/labcabrera/osm-code-generator[osm-code-generator].

== Requisitos

* JDK 8+
* Oracle Driver ojdbc6
